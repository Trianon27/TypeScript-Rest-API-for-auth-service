"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const ldapjs_1 = __importDefault(require("ldapjs"));
const search_1 = require("./services/search");
/** @description this is a class to provide low level promise base interaction with ldap server */
class Client {
    constructor(config) {
        /** connection status */
        this.getConnectionStatus = () => {
            return this.client.connected;
        };
        this.config = config;
        let reconnect = true;
        if (typeof config.reconnect !== "undefined") {
            reconnect = config.reconnect;
        }
        this.client = ldapjs_1.default.createClient(Object.assign(Object.assign({}, this.config), { reconnect, url: this.config.ldapServerUrl, log: this.config.logger }));
    }
    /** @return a connected ldap client that is useful for use flexibility of [ldap.js](http://ldapjs.org/) directly. */
    async bind(input) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("bind()");
        return new Promise((resolve, reject) => {
            var _a, _b;
            if (this.client) {
                this.client.destroy((err) => {
                    reject(err);
                });
            }
            this.client = ldapjs_1.default.createClient(Object.assign(Object.assign({}, this.config), { url: this.config.ldapServerUrl, log: this.config.logger }));
            this.client.on("connectError", (err) => {
                reject(err);
            });
            const user = (_a = input === null || input === void 0 ? void 0 : input.user) !== null && _a !== void 0 ? _a : this.config.user;
            const pass = (_b = input === null || input === void 0 ? void 0 : input.pass) !== null && _b !== void 0 ? _b : this.config.pass;
            if (user && pass) {
                this.client.bind(user, pass, (err, result) => {
                    if (err) {
                        reject(err);
                    }
                    resolve(this.client);
                });
            }
            else {
                reject(new Error(`user or pass not provided! you can provide in either bind function or when create new instance of client.`));
            }
        });
    }
    /** unbind connection */
    async unbind() {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("unbind()");
        return new Promise((resolve, reject) => {
            this.client.unbind((err) => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }
    /** unbind the connection and don't allow it to connect again. */
    async destroy() {
        return new Promise((resolve, reject) => {
            this.client.destroy((err) => {
                reject(err);
            });
            resolve();
        });
    }
    /** bind to server if client is not already bound */
    async connect() {
        var _a, _b;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("connect()");
        if ((_b = this.client) === null || _b === void 0 ? void 0 : _b.connected) {
            return this.client;
        }
        const client = await this.bind();
        return client;
    }
    /** @description raw search to provided full flexibility */
    async query({ options, controls, base, attributes, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("query()");
        await this.connect();
        const data = await search_1.search({
            client: this.client,
            base,
            options: Object.assign(Object.assign({}, options), { attributes: attributes }),
            controls,
        });
        return data;
    }
    /** @description raw search returns just attributes
     *
     * // TODO: add Generic type for return data
     */
    async queryAttributes({ options, attributes, controls, base, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("queryAttributes()");
        await this.connect();
        const data = await search_1.search({
            client: this.client,
            base,
            options: Object.assign(Object.assign({}, options), { attributes: attributes }),
            controls,
        });
        return data.map((entry) => entry.object);
    }
    /** Performs an add operation against the LDAP server.
     * @description Allows you to add an entry (which is just a plain JS object)
     */
    async add({ entry, dn, controls, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("add()");
        await this.connect();
        return new Promise((resolve, reject) => {
            if (controls) {
                this.client.add(dn, entry, controls, function addCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
            else {
                this.client.add(dn, entry, function addCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
        });
    }
    /** Performs a LDAP compare operation with the given attribute and value against the entry referenced by dn. */
    async compare({ dn, controls, field, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("compare()");
        await this.connect();
        return new Promise((resolve, reject) => {
            const [attribute, value] = Object.entries(field)[0];
            if (controls) {
                this.client.compare(dn, attribute, value, controls, function compareCallback(err, matched) {
                    if (err) {
                        reject(err);
                    }
                    resolve(matched);
                });
            }
            else {
                this.client.compare(dn, attribute, value, function compareCallback(err, matched) {
                    if (err) {
                        reject(err);
                    }
                    resolve(matched);
                });
            }
        });
    }
    /** Deletes an entry from the LDAP server. */
    async del({ dn, controls }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("del()");
        await this.connect();
        return new Promise((resolve, reject) => {
            if (controls) {
                this.client.del(dn, controls, function delCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
            else {
                this.client.del(dn, function delCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
        });
    }
    /**
     * @description Performs an extended operation against LDAP server.
     * @example
     * const {value} = await client.extendedOp('1.3.6.1.4.1.4203.1.11.3');
     * console.log('whois: ' + value);
     */
    async extendedOp({ oid, value, controls, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("extendedOp()");
        await this.connect();
        return new Promise((resolve, reject) => {
            if (controls) {
                this.client.exop(oid, value, controls, function extendedOpCallback(err, value, res) {
                    if (err) {
                        reject(err);
                    }
                    resolve({ value, res });
                });
            }
            else {
                this.client.exop(oid, value, function extendedOpCallback(err, value, res) {
                    if (err) {
                        reject(err);
                    }
                    resolve({ value, res });
                });
            }
        });
    }
    /**
     * @description Performs a LDAP modifyDN (rename) operation against an entry in the LDAP server. A couple points with this client API:
     * - There is no ability to set "keep old dn." It's always going to flag the old dn to be purged.
     * - The client code will automatically figure out if the request is a "new superior" request ("new superior" means move to a different part of the tree, as opposed to just renaming the leaf).
     */
    async modifyDn({ dn, newDn, controls, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("modifyDn()");
        await this.connect();
        return new Promise((resolve, reject) => {
            if (controls) {
                this.client.modifyDN(dn, newDn, controls, function modifyDnCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
            else {
                this.client.modifyDN(dn, newDn, function modifyDNCallback(err) {
                    if (err) {
                        reject(err);
                    }
                    resolve(true);
                });
            }
        });
    }
    /** Performs a LDAP modify operation against attributes of the existing LDAP entity. This API requires you to pass in a Change object.
     */
    async modifyAttribute({ dn, changes, controls, }) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace("modifyAttribute()");
        await this.connect();
        return new Promise((resolve, reject) => {
            if (controls) {
                this.client.modify(dn, changes, controls, function modifyCallBack(error) {
                    if (error) {
                        reject(error);
                    }
                    resolve(true);
                });
            }
            else {
                this.client.modify(dn, changes, function modifyCallBack(error) {
                    if (error) {
                        reject(error);
                    }
                    resolve(true);
                });
            }
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=index.js.map