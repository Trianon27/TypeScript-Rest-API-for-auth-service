"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeLog = exports.createLogger = exports.logToFile = void 0;
const pino_1 = __importDefault(require("pino"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./helpers/utils");
const variables_1 = require("./helpers/variables");
/**instance for log to console */
let logToConsole;
const defaultRetentionTime = 604800000; /** 7 days in milliseconds */
const defaultLogLevel = "info";
/** @returns a previously instantiated instance of Pino that logs to an automatically generated file in logs folder in root directory */
function createLogger(options) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const fileName = `${new Date().getTime()}.log`;
        const dirPath = (_a = options === null || options === void 0 ? void 0 : options.logDir) !== null && _a !== void 0 ? _a : variables_1.defaultLogFolder;
        const filePath = path_1.default.join(dirPath, fileName);
        /** make sure logs folder exist */
        yield utils_1.createDirectoryIfNotExist(dirPath).catch(function () {
            throw new Error("Logs Folder not Exist");
        });
        utils_1.deleteOldFiles({
            dirPath,
            options: {
                keepMetaFiles: true,
                keepAliveTime: (_b = options === null || options === void 0 ? void 0 : options.retentionTime) !== null && _b !== void 0 ? _b : defaultRetentionTime,
            },
        });
        const dest = pino_1.default.destination(filePath);
        logToConsole = pino_1.default(Object.assign({}, options));
        exports.logToFile = pino_1.default((_c = Object.assign(Object.assign({}, options), { prettyPrint: { colorize: false } })) !== null && _c !== void 0 ? _c : {}, dest);
        logToConsole.info(`Logging to file: ${filePath}`);
        return exports.logToFile;
    });
}
exports.createLogger = createLogger;
/** write message to both file and/or console */
function writeLog(message, config = { stdout: false, level: defaultLogLevel }) {
    var _a, _b;
    if (exports.logToFile) {
        exports.logToFile[(_a = config.level) !== null && _a !== void 0 ? _a : defaultLogLevel](message);
        if (config.stdout) {
            logToConsole === null || logToConsole === void 0 ? void 0 : logToConsole[(_b = config.level) !== null && _b !== void 0 ? _b : defaultLogLevel](message);
        }
    }
    else {
        /** fallback to console.log
         * if:
         *   - config provided
         *   - && log level is "info" || "fatal" || "warn" || "error"
         * else: do nothing
         */
        if (config && (config === null || config === void 0 ? void 0 : config.level) === ("info" || "fatal" || "warn" || "error")) {
            console.log(message);
        }
    }
}
exports.writeLog = writeLog;
//# sourceMappingURL=index.js.map